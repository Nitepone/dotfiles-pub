#! /bin/bash
#
# Automatically configures displays based on a simple config array.
# Absolutely cursed, but working...

# shellcheck disable=SC1090
source ~/.profile
export PATH=$HOME/.cargo/env:$PATH

set -x

# hint as to what the primary monitor should be. Else random selection.
DP_HINT_PRIMARY=("DP-2-3")

# strings that order monitors from left to right
# order in priority of config
# specify orientation (none, left, right, inverted)
DP_HINT_ORDERED_CONFIGS=("eDP-1 normal DP-4 normal" "eDP-1 normal DP-2-3 normal DP-2-2 normal" "eDP-1 normal DP-2-3 normal")
DH_CFG_PARAM_COUNT=2

BSPWM_DESKTOP_COUNT=13
BSPWM_SDS=80

function get_mon_index {
	for i in "${!con_mon[@]}"; do
	if [[ "${con_mon[$i]}" = "${1}" ]]; then
		echo "${i}"
	fi
	done
}

function enumerate_displays {
	local config
	local config_displays
	local output
	local orientation
	local prev_output
	local max_res_in_cfg
	local h_con_mon
	local cur_dim
	local xpos
	local ypos
	local mon_index
	xpos=0
	ypos=0

	# populated "connected displays"
	mapfile -t connected_displays < <(xrandr --query | awk '/ connected /{print$1}')

	con_mon=( "${connected_displays[@]}" )
	# w_con_mon=( $(xrandr | grep "   .*+" | sed -E "s/   ([0-9]*)x([0-9]*).*/\1/") )
	mapfile -t h_con_mon < <(xrandr | grep "   .*+" | sed -E "s/   ([0-9]*)x([0-9]*).*/\2/")
	IFS=$'\n'
	max_res_in_cfg="$(echo "${h_con_mon[*]}" | sort -nr | head -n1)"
	unset IFS

	# check configs for a matching one
	for config in "${DP_HINT_ORDERED_CONFIGS[@]}"; do
		echo "$config"
		IFS=" " read -r -a config <<< "$config"

		# check if config matches current displays
		config_displays=()
		for ((i=0; i<${#config[@]}; i+=DH_CFG_PARAM_COUNT)); do
			# add to list of config's displays
			config_displays+=("${config[i]}")
			# check if display not in connected array
			for i_display in "${connected_displays[@]}"; do
				if [[ "${i_display}" = "${config[i]}" ]]; then
					continue 2
				fi
			done
			echo "Config no match"
			continue 2
		done

		# apply config if match made
		echo -e "\\tmatch!"
		# apply monitor order/orientation
		for ((i=0; i<${#config[@]}; i+=DH_CFG_PARAM_COUNT)); do
			output="${config[i]}"
			orientation="${config[i+1]}"
			mon_index="$(get_mon_index "$output")"
			echo "$mon_index"
			xpos=0
			ypos=$(( max_res_in_cfg - h_con_mon[mon_index] ))
			# set display position if needed
			if ((i > 0)); then
				cur_dim="$(xdpyinfo | grep dimensions | sed -r 's/^[^0-9]*([0-9]+x[0-9]+).*$/\1/')"
				xpos=$(echo "$cur_dim" | sed -E 's/(.*)x.*/\1/')
				prev_output="${config[i-DH_CFG_PARAM_COUNT]}"
				xrandr --output "$output" \
					--right-of "$prev_output"
			fi
			# set orientation of display
			xrandr --output "$output" \
				--rotate "$orientation"
		done

		# apply fine monitor position
		for ((i=0; i<${#config[@]}; i+=DH_CFG_PARAM_COUNT)); do
			output="${config[i]}"
			mon_index="$(get_mon_index "$output")"
			xpos=$(xrandr | grep "$output" | sed -E "s/.*\+([0-9]*)\+.*/\1/")
			ypos=$(( max_res_in_cfg - h_con_mon[mon_index] ))
			# asserts all displays are aligned at bottom
			xrandr --output "$output" \
				--pos "${xpos}x${ypos}"
		done
		connected_displays=("${config_displays[@]}")
		echo "config applied!"
		return
	done

	# attempt failover, no config applied
	echo "I see no friendly monitors... This is scary... *sniff*"
	echo "Must.. Continue.. Using the first output I saw!"
	connected_displays=("${connected_displays[0]}")
	return
}

# expects bash array as "connected_displays" and DP_HINT_PRIMARY
function configure_bspwm_desktops {
	local primary
	local desktop_count

	# determine if we have a primary monitor attached
	for primary in "${DP_HINT_PRIMARY[@]}"; do
		for i_display in "${connected_displays[@]}"; do
			if [[ "${i_display}" = "$primary" ]]; then
				break 2
			fi
		done
		primary=""
	done

	# calculate desktop counts
	if [[ -z "$primary" ]]; then
		primary_desktop_count=0
		secondary_desktop_count=$((BSPWM_DESKTOP_COUNT/${#connected_displays[@]}))
	else
		secondary_desktop_count=$(( ( (BSPWM_DESKTOP_COUNT * BSPWM_SDS) / 100)\
			/${#connected_displays[@]}))
		primary_desktop_count=$((BSPWM_DESKTOP_COUNT - \
			secondary_desktop_count * (${#connected_displays[@]} - 1)))
	fi
	desktop_count=1

	# add desktops and configure for displays
	for display in "${connected_displays[@]}"; do
		if [[ "$display" = "$primary" ]]; then
			next_desktop_count=$((desktop_count + primary_desktop_count))
		else
			next_desktop_count=$((desktop_count + secondary_desktop_count))
		fi
		bspc monitor "$display" -d $(seq --separator=" " \
			"$desktop_count" "$((next_desktop_count - 1))")
		export MONITOR="$display"
		if [[ "$display" = "$primary" || $((${#connected_displays[@]} == 1)) ]]; then
			polybar bottomright &
		fi
		polybar bottomleft &
		desktop_count="$next_desktop_count"
	done
}


# XXX(nitepone) So... We need to do this while using the Nvidia GPU driver.
#               For some absolutely inexplicable reason. Running these bspc
#               commands seems to cause the Nvidia driver to asyncronously
#               populate the monitors where bspwm expects them.
#               Without running these commands, `bspc query` will only output
#               a placeholder "MONITOR".
#               This will cause anything relating to monitor configuration to
#               fail miserably.
#               (Note, the NV driver makes logs about HDMI during the sleep)
xrandr --auto
bspc config remove_disabled_monitors true
bspc config remove_unplugged_monitors true
while [[ "$(bspc query -M --names)" == "MONITOR" ]]; do
	sleep 1
done

# close old wm supporting app instances
pkill polybar
pkill nm-applet
pkill sxhkd
pkill feh
pkill wmname
pkill picom

# autoconfigure bspwm desktops
xrandr --auto
enumerate_displays
configure_bspwm_desktops

# configure bspwm
bspc config focus_follows_pointer true
bspc config border_width         5
bspc config window_gap          14
bspc config split_ratio          0.52
bspc config borderless_monocle   true
bspc config gapless_monocle      true
bspc config remove_unplugged_monitors true
bspc config remove_disabled_monitors true
bspc config focused_border_color "#44A7C4"
bspc config active_border_color "#022F8E"
bspc config normal_border_color "#011847"
bspc rule -a TeamViewer state=floating
bspc rule -a Peek state=floating

# fixes issues with java programs in tiling WMs
export _JAVA_AWT_WM_NONREPARENTING=1

# fork/start useful things
#   network manager systray util
nm-applet &
#   hotkey daemon
sxhkd &
#   Java compatible wmname
wmname LG3D &
#   wallpaper
feh --bg-fill ~/.config/wallpapers/background.png &
#   compositor
picom --experimental-backends --blur-method dual_kawase &

# configure xinput stuff
#   root cursor
xsetroot -cursor_name left_ptr
#   keyboard remapping
xmodmap -e "keycode 166 = Prior"
xmodmap -e "keycode 167 = Next"

set +x
